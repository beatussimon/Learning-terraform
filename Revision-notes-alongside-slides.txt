TERRAFORM:
Imperative Languages

You write explicit instructions for the computer to follow in order.

Think of it like giving a recipe: step 1, step 2, step 3.

You manage the program state and control flow (loops, conditionals).

Examples: C, Java, Python, JavaScript, Ruby.

Pros: More control, often easier for complex algorithms.

Cons: Can be more verbose and error-prone.

Declarative Languages

You specify what you want as the outcome, not the steps to get there.

The underlying system figures out how to achieve it.

Often more concise and readable.

Examples:

SQL (query data without specifying search algorithm)

HTML/CSS (describe page layout, not browser rendering steps)

Functional languages (like Haskell) emphasize declarative style.

Logic programming (Prolog).

Pros: Easier to reason about, less boilerplate.

Cons: Less control over performance and execution details.



Terraform sits in the middle between imperative and declarative  where it lets you use the declarative stuff wile fiving you
options to upgrade and up and use the complex data structure etc.

Infrastructure Lifecycle

Endede on 1:00:00


Terraform cont..
Visualizing the execution plans:
In cloud computing, provisioning is the process of setting up and configuring the necessary IT resources, like virtual machines, storage, and networking, to run applications and services. It includes both the initial setup of the underlying infrastructure and the on-demand allocation of resources and services to users, often automated to be fast and efficient. 
Key aspects of cloud provisioning
Infrastructure setup: This involves creating the foundational components of the cloud environment, such as networking, storage, and the virtualization layers.
Resource allocation: Once the infrastructure is in place, this step involves making specific resources available to users. This can include allocating virtual machines, databases, and other services as needed.
Automation: Modern cloud provisioning heavily relies on automation to make the process faster and less prone to human error. This can be done through scripts, templates like ARM templates, or tools that define infrastructure as code.
User access: It also includes establishing access for authorized users by setting up their accounts and permissions to access the resources they need.
Dynamic and self-service: Cloud provisioning can be dynamic, automatically adjusting resources based on demand, and can also be self-service, allowing users to request and set up their own resources through a portal. 

2:05:00

Complete Terraform Course - From BEGINNER to PRO! (Learn Infrastructure as Code) By devops directive

Provisioning: In IT, provisioning is the process of creating infrastructure and making it available to end users. Configuration: It is the process of configuring the provisioned IT infrastructure resources. For example, installing and configuring a database on a server or configuring network and firewall settings.1
Infrastructure is provisioned as code
Servers are created and destroyed in seconds
Long lived and mutable -> now they are short lived and immutable

Three main approaches for provisioning cloud resources:
=> GUI
-> API/CLI
-> Iac

Categories of Iac
-> Ad hoc scripts => tells you what infrastructure to provision
=> configuration management tools
=> server templating tool -> this category is for building out a template for what you are going to 
	provision to a server
	AMI=> amazon machine image or basically any machine image is built in from some image and you 
	all your dependencies into your image

=> orchastration tools

These are for how you can define your application deployment, less of how you can define the servers behind it
	but take your code and deploy it in a certain way in whatever system you have provisioned in the background

=> Provisioning tools
	Focused on provisioning those cloud resources to begin with

Declarative tools=> you define the end state of what you want eg. i want 5 servers 1 load balancer etc. and the tool manages the
	api and what calls needs to be made to make that happen
Imperative tools=> You tell the system what you want to happend and the sequence you want that to happen
	and most of the configuration tools falls on the imperative side of the tools that can make them more declarative

Lots of terraform tools falls on the declarative side where you define the end state of what you want to take place
and you then let the tool handle the details of how to get there


Terraform overview and setup:
Its a tool for building changing and versioning infrastructure safely and efficiently
Enables application software best practices to infrastructure

Its cloud agnostic

parker=> server templating where you can build everything with that template, so that when you build it has both the application code and 
dependencies bundled in the code

Common patterns:
terraform + ansible
terraform + parker(server templating)
terraform + orchastration tools


at the core we have terraform core
we provide the config and terraform will figure out interacting with the cloud provider to maintain the 
desired state of what was required by the config files

the AMI is the amazon machine image containig the full set of information required to create an EC2 vir
tual machine instance

Basic terraform usage:
terraform init=> plan=> apply => destroy

State file:
-> is the terraform's representation of the world 
-> JSON file containing information about every resource and data object
-> contains sensitive info
-> can be stored locally or remotely

terraform plan
takes the desired state and compares it to the actual state of the world

terraform destroy => destroys everything

for remote we have terraform cloud but we can also manage ourself using s3 and 
dynamo db which has state locking and will prevent the concurrent state changes 
when different users are working on the same file, for instance when a user is 
running terraform plan the other will have to wait for that command to finish before the 
command from the other user is executed


Variables and output:
variable types:
input variables => var.<name>
local variables => local.<name>
output variables => 

Setting input variables:
(In order of precedence //lowest to highest)
-manual entry during plan/apply
-default value in declaration block
-TF_VAR_<name> environment variables
-terraform.tvars file
-*.auto.tfvars file
-commandline -var or -var-file

validation:
-Type checking happens automatically
-Custom conditions can also be enforced => You can run your own custom validation rules

sensitive data:
=mark a variable as sensitive
-Pass to terraform apply with 
TV_VAR_variable
	-> -var (retrieved from secret manager at runtime)

if the filename having your variables isn't tfvars you have to tell terraform 
using the command terraform apply -var-file=additional_tfvars_file

Expressions and functions => use the documentation for more reference


Meta arguments:
depends_on => if you have things depending on others -> terraform will figure out
the sequence of the things during execution 

Notes:
terraform automatically generates the dependency graph based on references
-> If two resources depend on each others data) depends_on specifies that dependency to 
enforce ordering

For example if the software instance needs access to s3 storage, trying to create the aws_instance
would fail if attempting to create it before the aws_iam_role_policy

Count:
Allows for creation of multiple resources/modules from a single block
-> Useful when multiple neccesary resources are nearly identical 

if you have several identical resources you created using count; you have to use
tag to differentiate them


for_each
-allows creation of multiple resources/modules from a single block
-allows more control to customize each resource than count

Lifecycle:
A set of meta argument to control terraform behaviour for speciefic resources

-create_before_destroy can help with zero downtime deployments
-ignore changes prevents terraform form reverting metadata being set elsewhere

-prevent destroy causes terraform to reject any plan which would reject this resource

Provisioners -> performs actions on local or remote machines

file
local-exec
remote-exec
vendor=> chef, puppet, ansible

Part 6: Project organization and modules
1:20:00	
